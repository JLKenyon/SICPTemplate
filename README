
SICPTemplate

Abstract

This project is meant to be an empty set of templates ready for use with the SICP book in any of several languages (Starting with Haskell but I hope to add stubs for other languages as time goes by).  This project should not contain solutions directly, as users of this project are expected to fill these in as they progress through the book on their own.  There may be unit tests included (the haskell project included from the start has a framework in place for running tests), and these may "imply" solutions, but they are not supposed to be viewed directly by the user.

Requirements

Haskell - based on GHC (hugs untested)
  Install via cabal:
    HUnit  QuickCheck  test-framework-hunit  test-framework-quickcheck2  
    test-framework  random  directory  process  unix  filepath  haskell98

Scheme - based on Racket, and raco
  install from planet
    (require (planet schematics/schemeunit:3:4))

History

I started this project acter I tried starting to go through SICP, and very quickly got very unorganized.  This was for several reasons, such as my initial selection to approach the book using the Haskell language instead of scheme. Additionally, my work was scattered across different files, and I did not have the language specific knowledge to assemble separate files into a whole cohesive project.  So I took time off of the book to focus on haskell's systems for building a coherent project and libraries availible for doing unit testing.  With the haskell libraries in place, things went more smoothly, but I decided to change to scheme (racket) to speed up the processes even further, and a unit testing framework has been taken from planet and a set of template files with sub-project mains has been created.

Ideal goal

Obviously, this book represents a lot of material, and creating stubs, notes, and unit tests for every section and problem in the book is going to be a huge undertaking, which will only be multiplied by the number of languages which will be included.  And of course, I would like to support a broad selection of languages, hopefully including: Clojure, Scala, Ocaml, Common Lisp, Ruby, Python and any other languages that people desire. Of course my immediate personal interest is getting through the material myself, but I would like to leave for future students an organized basis for their completion of the material as well.  At this point, I am not sure how to complete this task.

General Structure

Each language should have an Sicp directory which marks the root of the actual book material.  Within this there are two branches of sorts, one being a collection of chapters, which break down into sections and then parts, reflecting the structure of the book.  The other is a testing directory, which internally breaks down into the same structure of chapter/section/part.  In the former portion, developers should fill in stubs for functions to be implemented, simple data structures if relevant, and comments relating these to the relevant section of the book.  Users would then fill in the stubs with actual code.  In the later portion, the testing portion, developers should create tests based on the stubs and comments in the former portion. Users should not look at the unit tests at all.

Paths to completion

The first task which I plan on completing is my continued work on the scheme portion of the template, attempting to back-fill the stubs that I use in my own work into the template.  With this in place, it would be reasonable to review, refactor and clean up the stubs.  A third step would be to fill in as many unit tests as possible to the project.  This, would complete the first phase of the project, a single language completed.  The extension of the project to include other languages would prove challenging, obviously the function stubs, comments and unit tests should be similar across all languages, so I wonder if future languages should be generated by some sort of automated conversion from a common language independant template, or by the selection of a master language (scheme) which all other languages should be adapted to by way of human labor.  This, I have not an answer...



